* Introduction
This is a top-down introduction to core.logic which
attempts to lead you that elusive AHA! moment of understanding what
logic programming is about.

* Logic Programming
A logic program consists of a logic expression(s) and a solution
engine or solver.  A logic expression is a set of logic variables and
constraints upon those variables.  The logic expression is input to the
logic engine which returns all assignments to the logic variables that
satisify the constraints in the expresion.  Generally speaking you
write the logic expressions, and the solver is provided (core.logic is
the solver).

This setup is similar to SQL, which is a relational statement that is
input to a relational engine which returns all data in the database satisfying that
statement.

* Core.logic syntax
A core.logic program is written

 (run* [logic-variable] &logic-expressions)

This means: take the set of logic-expressions, run them through the
solver and return all the values of logic-variable that satisfy the
logic-expression.

** Logic Expression
A logic expression comprises a set of logic variables and a set of
constraints upon the values that those logic variables can assume.

*** Logic Variables
A logic variable, or lvar, is a variable that contains an ambiguous
value. That is, the variable can take several values, but only one at a
time. How this is precisely done is beyond the scope of this
introduction.

*** Constraints
Constraints are expressions that limit the values the lvars may assume.

* Motivating Example

An example is useful here.  The core.logic program

 (run* [q]
       (membero q [1 2 3])
       (membero q [2 3 4]))

is read: run the logic engine and return all values of q such that q
is a member of the vector [1 2 3] and a member of the set [2 3 4].  It
will thus return (2 3), indicating that q can be either 2 or 3 and
satisfy the constraints.  The return value of run* is a list where each
element is one of the possible values of q.

This is what logic programming is all about: declaring a set of logic variables and
constraints and having a logic engine figure out what values of
variables satisfy the constraints.

* Going deeper
We now explore each of these concepts further to develop a better understanding.

** Logic Variables

As mentioned logic variables are variables with an ambiguous value,
which when printed look like lists, where each element of the list is
one possible value of the variable. 

A special value for lvars is _ which means "anything", much as * means
"anything" in a shell, this means that the lvar can take on any value
and still satisfy the constraints. This is called the ground state.
Furthermore, if you have two variables, that can be anything they will
have values _.0 and _.1,meaning that each can be anything and they can
be distinct from another, whereas if they were both _.0 it would mean
they can be anything but must be equal to another.

Logic variables are introduced into a program in two ways.

The first is the main query variable introduced in

 (run* [query-variable] ...)

whose value will be the return value of the (run* ...) expression. There
can only be one such main query variable, and it is usually named q.

The other method of introducing logic variables is using the 'fresh'
operator, much like 'let' in normal Clojure.  For instance the snippet

 (fresh [a b c] &logic-expressions)

introduces three logic variables, a, b and c, that may be used within
the logic-expressions.  fresh introduces the variables in the ground state.

** More on Constraints
Logic expressions constrain the values of logic variables.  They are
composed of several constraints that are combined in a logical AND
(conjunction). So in

 (run* [q]
   (constraint-1)
   (constraint-2)
   (constraint-3))

each expression constrains q in some way, and run* will return the
values of q that satisfies all three expressions.  

*** Goals
core.logic is based upon miniKanren and in this system we create
constraints in a particular way.  Each is a function that returns one of two
values: succeed or fail. When a goal returns succeed we say it has
succeeded, and if it returns fail that it has failed.  The logic engine explores the possible
values of all the lvars and returns those for which all the goals
succeed.  Hence the goals behave as a conjunction of constraints upon the lvars.

** The core.logic operators
miniKanren and hence core.logic are based upon three core operators:
fresh, == and conde.

*** fresh
We have already seen fresh, which introduces new lvars, in the ground state, into the logic
program.

*** Unify, the most basic operator
The most fundamental operator is ==, or unify:

 (== lvar1 lvar2)

which serves to constrain each lvar to have the same set of possible
values.  It is a goal that succeeds if lvar1 can be made equal to
lvar2, otherwise it fails.

**** Unification of a single lvar and a literal
In the simplest case you can use Clojure literals for lvar1 or lvar2.
For example the expression:

 (run* [q]
   (== q 1))

constrains q to have the value of 1.  The whole run* expression
evaluates to the value of the lvar q, hence it returns (1).  This
means that the set of possible values that q can assume, under this
constraint is only the integer 1.  You can use more complex datatypes
too:

 (run* [q]
   (== q {:a 1 :b 2}))

evaluates to: ({:a 1, :b 2}).

Finally, the order of the arguments to == is irrelevent,

 (run* [q]
   (== 1 q))

is also (1).

Gotcha: Now although when printed an lvar looks like a list, this is
not the literal syntax for an lvar; there is not in fact a literal
syntax for an lvar.  So the program

 (run* [q]
   (== q '(1 2 3)))

evaluates to ((1 2 3)), not (1 2 3), which you might not expect.  That
is, q can only take the value of the list (1 2 3), not either 1 or 2
or 3.

As stated above run* finds the solutions that satisfies all the
constraints, alternatively think of all the logical statements 
combined with logical AND. Thus,

 (run* [q]
   (== q 1)
   (== q 2))

returns (); there are no values of q that satisfy all the constraints.
That is, it's impossible for q to equal 1 AND for q to equal 2 at
the same time.

**** Unification of two lvars
When you unify two lvars, the operation constrains each lvar to have
the same set of possible values.  A mental shortcut is to consider
unification to be the intersection of the two sets lvar values that
exists 'before' unification.  For instance, if, without the
introduction of the unification lvar1 has value (1, 2, 3) and lvar2
has value (3, 4, 5), then, with unification, both will have the value
(3).

To demonstrate this we have to cheat and go out of order a bit.  As
stated there is no literal syntax for an lvar, so to constrain lvar1
to have value (1, 2, 3), we have to introduce a goal, membero:

 (membero x l)

For now, and this true but not the full story, think of it as
constraining x to be an element of the list l.  So the program

 (run* [q]
   (membero q [1 2 3]))

evaluates to (1, 2, 3), meaning that q can be
either 1 or 2 or 3, as we wanted.  Now we have our full demonstration:

 (run* [q]
   (fresh [a]
     (membero q [1 2 3])
     (membero a [3 4 5])
     (== q a)))

First we use run* and ask it to return the value of the lvar q under a
set of constraints.  Then we introduce a new lvar, a.  Next come the
three constraints which q must sati.  First we constrain q, as in the
previous problem to have the value (1, 2, 3), that is, q can be either
1 or 2 or 3, and the lvar a to have the value (3, 4, 5), that is, a
can be 3 or 4 or 5.  Then we unify the two lvars, which leaves q and a
both having the value of the intersection of (1, 2, 3) and (3, 4, 5):
(3).  Note the logical AND between the expressions: run* returns the
value of q that satisfies all of the constraints.  Finally, as the
whole thing evaluates to the value of q, it will evaluate to (3).

**** Core.logic is Declarative
Now some magic.  Core.logic is entirely declarative, in that the order
of constraints does not matter as far as the value of the (run* ...)
expression is concerned.  So the programs:

 (run* [q]
   (fresh [a]
     (membero q [1 2 3])
     (membero a [3 4 5])
     (== q a)))

 (run* [q]
   (fresh [a]
     (membero a [3 4 5])
     (== q a)
     (membero q [1 2 3])))

 (run* [q]
   (fresh [a]
     (== q a)
     (membero a [3 4 5])
     (membero q [1 2 3])))

all evaluate to (3).

*** The final operator, conde
We have introduced run*, fresh and ==, and there is only one more
operator: conde. Unsurprisingly conde behaves a lot like cond, and is
logical disjunction (OR). Its syntax is

 (conde &clauses)

where each clause is a series of at least one goal, which are combined
in conjunction.  conde succeeds for each clause that succeeds,
independently.  Yes, that is confusing, some examples may help:

 (run* [q]
      (conde
       (succeed)))

returns (_.0).  conde succeeds because succeed succeeds, however q is
not involved and hence can take on any value.

There can be any number of goals in the clause

 (run* [q]
      (conde
       (succeed succeed succeed succeed)))

also returns (_.0) and each term in the clause for conde succeeds, and
the combined in logical conjunction.

Each goal in the clause is combined in logical conjuction (AND)

 (run* [q]
      (conde
       (succeed succeed fail succeed)))

returns (), as conde has failed and hence no value of q can create
success.  conde failed because of the fail in the clause, which due to
the conjunction causes the entire clause to fail.

conde succeeds/fails for each clause independently

(run* [q]
      (conde
       (succeed)
       (succeed)))

returns (_.0 _.0).  There are two values here because conde succeeds
twice, once for each clause.

The above examples show the logical structure, but lets see some output.

 (run* [q]
      (conde
       (succeed (== q 1))))

returns (1).  This is because succeed and (== q 1) both succeed, if q
is 1.  Having two elements in the conde clause is the usual structure
as it reminds us of cond, bear in mind the difference though.

(run* [q]
      (conde
       ((== q 2) (== q 1))))

returns ().  If you think of conde too much like cond you might expect
it to return (1).  You would think (== q 2) succeeds (like returning
true in cond) and then the expression (== q 1) is evaluated and
succeeds, setting q to 1. This is wrong!  Each expression in the clause is combined in AND,
in this case it is not possible for q to be 2 and 1 at the same time,
hence the clause fails, hence conde fails, so with no way to achieve
success q has value ().

 (run* [q]
      (conde
       ((== q 1))
       ((== q 2))))

returns (1 2).  The difference here is that each unification is in a
different clause of conde, and each can succeeds independently,
producing a value for q.

** More Goals
We've seen the interaction of the three operators, but these are the
primitives of logic programming. core.logic provides some other
goals based on these primitives, let's take a look at a
few of them.

*** Conso (the Magnificent)
The most basic goal is conso; understand this and the rest will
follow.  Conso is the most basic core.logic goal, and is,
unsurprisingly, the logic programming equivalent of normal
cons. Recall

 (cons x r) returns s

where s is a seq with the element x as its head and the seq r as its rest:

 (cons 0 [1 2 3])  returns (0 1 2 3).

Conso is similar

 (conso x r s)

It constrains the logic variables x, r and s such that s is a list
with head x and rest r.  Again we can use either lvars or literals for
any of x r s. So:

 (run* [q]
   (conso 1 [2 3] q))

returns ((1 2 3)); that is, q is the lvar than can only take on the
value of the list '(1 2 3).  We have asked run* to find the value of
q, being a list, with head 1 and rest [2 3], and it finds '(1 2 3).

Now some more magic:

 (run* [q]
   (conso 1 q [1 2 3]))

returns ((2 3)); that is q is constrained to be that list which, when
1 is added as the head results in the list (1 2 3).

  (run* [q]
    (conso q [2 3] [1 2 3]))

returns (1); q is the element that when added to the head of [2 3]
results in [1 2 3].  Even more interesting:

  (run* [q]
    (conso 1 [2 q] [1 2 3]))

returns (3); q is that element of the list [2 element] that when 1 is
added as the head becomes the list [1 2 3].

In summary: (conso f r s) succeeds if (first s) is f and (rest s) is r.

*** Resto
Resto is the complement of conso

 (resto l r)

constrains whatever logic variables are present such that r is (rest
l).  So

 (run* [q]
   (resto [1 2 3 4] q))

returns ((2 3 4)).  The same reorderings and substitutions that we
showed for conso apply here too.

In summary: (resto l r) succeeds if (rest l) is r.

*** Membero

We've already had a sneak peak at membero:

 (membero x l)

constrains whatever logic variables are present such that x is an
element of l.

 (run* [q]
   (membero q [1 2 3]))

returns (1, 2, 3); that is, either 1 or 2 or 3.

 (run* [q]
   (membero 7 [1 3 8 q]))

returns (7), the only value that q can take such that 7 is an element
of [1 3 8 q].

In summary: (membero x l) succeeds if x is any of the members of l.

* Summary
This introduction has given the basic idea of logic programming: it is
a set of variables and constraints upon them, which are fed into a
solution engine which returns the complete set of consistent solutions
to that set of constraints. 

The key concepts are the logic variable and the goal.  A logic
variable  is a variable that can assume a number of distinct values
one at a time.  A goal is a function that returns succeed or
fail. Goals are composed into a logic expression.  Run* invokes the
logic engine over a logic expression and returns the complete set of
values of the query logic variable that allow the logic expression to succeed.

